#!/usr/bin/env node
/**
 * FasGen — FastAPI Application Scaffold Generator
 *
 * Single-file Node.js CLI that writes a fully-commented FastAPI API project.
 *
 * Why Node for a Python generator?
 * - Mirrors your G.E.S.A. workflow 
 * - Super portable; easy string templating; no Python bootstrap needed to generate Python
 *
 * Key features (per your spec):
 * - Python 3.13.2 (configurable via --py)
 * - pip (not poetry/pipenv)
 * - pytest + ruff + black + mypy
 * - API-only FastAPI with JWT auth
 * - Concurrency demos (parallel I/O, CPU offload, semaphore, BackgroundTasks)
 * - SQLite by default; --psg (Postgres), --msql (MySQL) toggles
 * - CORS default "*", modular
 * - -d/--docker adds Dockerfile (+ optional docker-compose with prompts)
 * - Optional services with prompts: Postgres, MySQL, Redis, Nginx
 * - Optional GitHub Actions CI with --ci
 * - MIT license, detailed README
 */

const fs = require("fs");
const path = require("path");
const readline = require("readline");

// ---------- tiny helpers ----------
function out(...args) { console.log(...args); }
function err(...args) { console.error(...args); }
function die(msg) { err(msg); process.exit(1); }
function writeFileSafe(p, content) {
  fs.mkdirSync(path.dirname(p), { recursive: true });
  fs.writeFileSync(p, content, "utf8");
}
function yesNoPrompt(question) {
  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  return new Promise(res => rl.question(`${question} (y/N): `, ans => { rl.close(); res(/^y(es)?$/i.test(ans.trim())); }));
}
function parseArgs(argv) {
  const args = { _: [] };
  for (let i = 2; i < argv.length; i++) {
    const a = argv[i];
    if (a === "-h" || a === "--help") args.help = true;
    else if (a === "-d" || a === "--docker") args.docker = true;
    else if (a === "--psg") args.psg = true;
    else if (a === "--msql") args.msql = true;
    else if (a === "--redis") args.redis = true;
    else if (a === "--ngnx") args.ngnx = true;
    else if (a === "--ci") args.ci = true;
    else if (a === "--port") { args.port = Number(argv[++i]); }
    else if (a === "--py") { args.py = String(argv[++i]); }
    else if (a.startsWith("-")) die(`Unknown option: ${a}`);
    else args._.push(a);
  }
  return args;
}

// ---------- templates (kept inline & heavily commented) ----------
function tpl_gitignore() {
  return `__pycache__/
*.pyc
*.pyo
*.pyd
*.db
.env
.venv/
venv/
dist/
build/
.coverage
.pytest_cache/
`;
}

function tpl_env_example(port) {
  return `# .env.example
# Copy to .env and change values for your environment.
APP_NAME=fastapi-app
ENV=dev
HOST=0.0.0.0
PORT=${port}

# SECURITY
JWT_SECRET=change-me-in-prod
JWT_ALG=HS256
JWT_EXPIRE_MIN=60

# CORS (for browsers). "*" is permissive; lock down in prod.
CORS_ORIGINS=*

# RATE LIMIT (simple in-process token bucket; use Redis at scale)
RATE_LIMIT_RPS=5
RATE_LIMIT_BURST=20

# CONCURRENCY CAP (for heavy endpoints)
MAX_INFLIGHT_JOBS=32

# DATABASE (SQLite default)
SQLITE_PATH=data/app.db

# Optional DB URLs (used if you wire Postgres/MySQL libs)
# POSTGRES_URL=postgresql+asyncpg://user:pass@postgres:5432/app
# MYSQL_URL=mysql+aiomysql://user:pass@mysql:3306/app
`;
}

function tpl_requirements() {
  return `fastapi==0.115.0
uvicorn[standard]==0.30.6
gunicorn==22.0.0
httpx==0.27.2
bcrypt==4.2.0
PyJWT==2.9.0
python-multipart==0.0.9
jinja2==3.1.4
# Optional DB clients (add if you actually use them)
# asyncpg==0.29.0      # Postgres async driver
# aiomysql==0.2.0      # MySQL async driver
`;
}

function tpl_pyproject() {
  return `[tool.black]
line-length = 100
target-version = ["py313"]

[tool.ruff]
line-length = 100
target-version = "py313"
select = ["E","F","I","UP","B"]
ignore = ["E501"] # Black handles line length
fix = true

[tool.mypy]
python_version = "3.13"
warn_unused_ignores = true
strict_optional = true
check_untyped_defs = true
ignore_missing_imports = true
`;
}

function tpl_tests() {
  return `# tests/test_health.py
def test_sanity():
    assert 1 + 1 == 2
`;
}

function tpl_readme(project) {
  return `# ${project}

A **small-footprint FastAPI API** scaffold generated by **fasgen** with:

- Python 3.13
- FastAPI (API-only; Jinja used only for mail template example)
- JWT auth (\`/api/auth/signup\`, \`/api/auth/login\`, \`/api/auth/me\`)
- Concurrency patterns: parallel I/O, CPU offload, global semaphore, BackgroundTasks
- SQLite by default (modular to add Postgres/MySQL)
- CORS default "*"
- Security headers, simple in-process rate limit
- Optional Dockerfile + docker-compose (if chosen at generation)
- Dev tooling: pytest, ruff, black, mypy
- MIT license

## Quickstart

\`\`\`bash
python -m venv .venv && source .venv/bin/activate
pip install -r requirements.txt
cp .env.example .env
export JWT_SECRET=$(python - <<'PY'\nimport secrets;print(secrets.token_hex(32))\nPY)

# dev server (auto-reload for development):
uvicorn app.main:app --host 0.0.0.0 --port \${PORT:-8000} --reload
\`\`\`

## Docker (if included)

\`\`\`bash
docker build -t ${project}:latest .
docker run -p 8000:8000 -e JWT_SECRET=\$(openssl rand -hex 32) ${project}:latest
\`\`\`

## Endpoints

- \`GET /api/health\`  (liveness)
- \`GET /api/ready\`   (readiness)
- \`POST /api/auth/signup\`
- \`POST /api/auth/login\`
- \`GET /api/auth/me\`
- \`GET /api/demo/io\`          (parallel I/O)
- \`GET /api/demo/cpu\`         (CPU offload)
- \`GET /api/demo/heavy\`       (guarded by semaphore)
- \`POST /api/demo/background\` (BackgroundTasks)

## Concurrency notes

- **Async I/O** via \`asyncio.gather\` and a shared \`httpx.AsyncClient\`.
- **CPU offload** via \`asyncio.to_thread\` so the event loop stays responsive.
- **Backpressure** via a global \`asyncio.Semaphore\` configured by \`MAX_INFLIGHT_JOBS\`.
- **Fire-and-forget** via FastAPI's \`BackgroundTasks\` (tiny tasks only).

## Security notes

- **JWT bearer** tokens (HS256); rotate secret in prod.
- **bcrypt** password hashing (never store plaintext).
- **CORS** default is "*", lock down in prod by origin list.
- **Security headers** middleware set sane defaults.
- **Rate limiting** is per-process demo; use Redis/edge in prod.

MIT © You
`;
}

function tpl_license_mit(project) {
  const year = new Date().getFullYear();
  return `MIT License

Copyright (c) ${year} ${project}

Permission is hereby granted, free of charge, to any person obtaining a copy
... (standard MIT text unchanged) ...
`;
}

function tpl_gunicorn_conf() {
  return `"""
Gunicorn + Uvicorn workers for ASGI.
- workers = (2 * CPU) + 1 is a common baseline (tune with metrics).
- threads=1 since we rely on async I/O.
"""
import multiprocessing, os

bind = f"0.0.0.0:{os.getenv('PORT', '8000')}"
worker_class = "uvicorn.workers.UvicornWorker"
workers = int(os.getenv("WEB_CONCURRENCY", str(2 * multiprocessing.cpu_count() + 1)))
threads = int(os.getenv("WEB_THREADS", "1"))
timeout = int(os.getenv("TIMEOUT", "60"))
keepalive = int(os.getenv("KEEPALIVE", "5"))
accesslog = "-"
errorlog  = "-"
loglevel  = os.getenv("LOG_LEVEL", "info")
`;
}

function tpl_dockerfile(pyVer) {
  return `# Small & secure runtime image
FROM python:${pyVer}-slim

ENV PYTHONDONTWRITEBYTECODE=1 \\
    PYTHONUNBUFFERED=1

# Minimal OS deps (no compilers) — keeps image small
RUN apt-get update && apt-get install -y --no-install-recommends \\
      ca-certificates curl && \\
    rm -rf /var/lib/apt/lists/*

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Non-root user for defense in depth
RUN useradd -ms /bin/bash appuser
USER appuser

COPY --chown=appuser:appuser app/ ./app/
COPY --chown=appuser:appuser gunicorn_conf.py .

ENV ENV=prod PORT=8000
EXPOSE 8000

# Robust production serving (multi-worker)
CMD ["gunicorn", "-c", "gunicorn_conf.py", "app.main:app"]
`;
}

function tpl_compose({ includeApi, includePostgres, includeMySQL, includeRedis, includeNginx, port }) {
  // Compose is generated dynamically based on answers
  const lines = [];
  lines.push(`services:`);
  if (includeApi) {
    lines.push(`  api:`);
    lines.push(`    build: .`);
    lines.push(`    image: api-fast:latest`);
    lines.push(`    environment:`);
    lines.push(`      ENV: dev`);
    lines.push(`      APP_NAME: "fastapi-app"`);
    lines.push(`      JWT_SECRET: "change-this-in-prod"`);
    lines.push(`      CORS_ORIGINS: "*"`);
    lines.push(`      RATE_LIMIT_RPS: "5"`);
    lines.push(`      RATE_LIMIT_BURST: "20"`);
    lines.push(`      MAX_INFLIGHT_JOBS: "32"`);
    lines.push(`      PORT: "${port}"`);
    if (includePostgres) lines.push(`      POSTGRES_URL: "postgresql+asyncpg://user:pass@postgres:5432/app"`);
    if (includeMySQL)    lines.push(`      MYSQL_URL: "mysql+aiomysql://user:pass@mysql:3306/app"`);
    lines.push(`    ports: ["${port}:${port}"]`);
    lines.push(`    depends_on: [${[
      includePostgres ? "postgres" : null,
      includeMySQL ? "mysql" : null,
      includeRedis ? "redis" : null,
      includeNginx ? "proxy" : null
    ].filter(Boolean).join(", ")}]`);
  }
  if (includePostgres) {
    lines.push(`  postgres:`);
    lines.push(`    image: postgres:16`);
    lines.push(`    environment:`);
    lines.push(`      POSTGRES_DB: app`);
    lines.push(`      POSTGRES_USER: user`);
    lines.push(`      POSTGRES_PASSWORD: pass`);
    lines.push(`    ports: ["5432:5432"]`);
    lines.push(`    volumes: ["pgdata:/var/lib/postgresql/data"]`);
  }
  if (includeMySQL) {
    lines.push(`  mysql:`);
    lines.push(`    image: mysql:8`);
    lines.push(`    environment:`);
    lines.push(`      MYSQL_DATABASE: app`);
    lines.push(`      MYSQL_USER: user`);
    lines.push(`      MYSQL_PASSWORD: pass`);
    lines.push(`      MYSQL_ROOT_PASSWORD: root`);
    lines.push(`    command: --default-authentication-plugin=mysql_native_password`);
    lines.push(`    ports: ["3306:3306"]`);
    lines.push(`    volumes: ["mysqldata:/var/lib/mysql"]`);
  }
  if (includeRedis) {
    lines.push(`  redis:`);
    lines.push(`    image: redis:7`);
    lines.push(`    ports: ["6379:6379"]`);
  }
  if (includeNginx) {
    lines.push(`  proxy:`);
    lines.push(`    image: nginx:stable`);
    lines.push(`    volumes: ["./nginx.conf:/etc/nginx/nginx.conf:ro"]`);
    lines.push(`    ports: ["80:80"]`);
    lines.push(`    depends_on: [api]`);
  }
  if (includePostgres) lines.push(`volumes:\n  pgdata: {}`);
  if (includeMySQL)   lines.push(includePostgres ? `  mysqldata: {}` : `volumes:\n  mysqldata: {}`);
  return lines.join("\n") + "\n";
}

function tpl_nginx_conf(port) {
  return `# Minimal reverse proxy to the FastAPI container
events { worker_connections 4096; }
http {
  server {
    listen 80;
    server_name _;

    # Proxy to API
    location / {
      proxy_pass http://api:${port};
      proxy_set_header Host $host;
      proxy_http_version 1.1;
    }
  }
}
`;
}

// ------------------- Python app templates -------------------

function tpl_app_config_py() {
  return `"""
app/config.py
Centralized settings (12-factor): values from env vars with safe dev defaults.
"""
from pydantic import BaseModel
import os

class Settings(BaseModel):
    APP_NAME: str = os.getenv("APP_NAME", "fastapi-app")
    ENV: str = os.getenv("ENV", "dev")            # dev|staging|prod
    HOST: str = os.getenv("HOST", "0.0.0.0")
    PORT: int = int(os.getenv("PORT", "8000"))

    # JWT
    JWT_SECRET: str = os.getenv("JWT_SECRET", "dev-only-change-me")
    JWT_ALG: str = os.getenv("JWT_ALG", "HS256")
    JWT_EXPIRE_MIN: int = int(os.getenv("JWT_EXPIRE_MIN", "60"))

    # CORS
    CORS_ORIGINS: list[str] = os.getenv("CORS_ORIGINS", "*").split(",")

    # Rate limit (toy, per-process)
    RATE_LIMIT_RPS: float = float(os.getenv("RATE_LIMIT_RPS", "5"))
    RATE_LIMIT_BURST: int = int(os.getenv("RATE_LIMIT_BURST", "20"))

    # Concurrency cap (for heavy endpoints)
    MAX_INFLIGHT_JOBS: int = int(os.getenv("MAX_INFLIGHT_JOBS", "32"))

    # SQLite default path (modular; swap to Postgres/MySQL if needed)
    SQLITE_PATH: str = os.getenv("SQLITE_PATH", "data/app.db")

settings = Settings()
`;
}

function tpl_app_models_py() {
  return `"""
app/models.py
Pydantic schemas and a toy in-memory "DB" for auth demo.
Swap to real DB later (SQLAlchemy + Postgres/MySQL).
"""
from pydantic import BaseModel, EmailStr, Field
from datetime import datetime

class SignupIn(BaseModel):
    email: EmailStr
    password: str = Field(min_length=8)

class LoginIn(BaseModel):
    email: EmailStr
    password: str

class TokenOut(BaseModel):
    access_token: str
    token_type: str = "bearer"
    expires_minutes: int

class ProfileOut(BaseModel):
    email: EmailStr
    created_at: datetime

# In-memory store: good for demos/tests only (single-process)
USERS: dict[str, dict] = {}
`;
}

function tpl_app_auth_py() {
  return `"""
app/auth.py
Password hashing (bcrypt), JWT issue/verify, current_user dependency.
"""
from datetime import datetime, timedelta, timezone
from typing import Optional
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
import bcrypt, jwt

from .config import settings
from .models import USERS

bearer = HTTPBearer(auto_error=False)

def hash_password(plain: str) -> str:
    return bcrypt.hashpw(plain.encode("utf-8"), bcrypt.gensalt()).decode("utf-8")

def verify_password(plain: str, hashed: str) -> bool:
    try:
        return bcrypt.checkpw(plain.encode("utf-8"), hashed.encode("utf-8"))
    except Exception:
        return False

def create_jwt(sub: str, minutes: int = settings.JWT_EXPIRE_MIN) -> str:
    now = datetime.now(tz=timezone.utc)
    payload = {
        "sub": sub,
        "iat": int(now.timestamp()),
        "exp": int((now + timedelta(minutes=minutes)).timestamp()),
        "nbf": int(now.timestamp()),
        "iss": settings.APP_NAME,
    }
    return jwt.encode(payload, settings.JWT_SECRET, algorithm=settings.JWT_ALG)

def verify_jwt(token: str) -> dict:
    try:
        return jwt.decode(token, settings.JWT_SECRET, algorithms=[settings.JWT_ALG], options={"require": ["exp", "iat", "nbf"]})
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Token expired")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token")

def get_current_user(creds: Optional[HTTPAuthorizationCredentials] = Depends(bearer)) -> str:
    if creds is None or creds.scheme.lower() != "bearer":
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Missing bearer token")
    data = verify_jwt(creds.credentials)
    email = data.get("sub")
    if not email or email not in USERS:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="User not found")
    return email
`;
}

function tpl_app_utils_py() {
  return `"""
app/utils.py
Security headers, simple per-process rate limiter, CPU offload, concurrency guard.
"""
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request
from starlette.responses import Response, JSONResponse
from time import monotonic
from typing import Dict, Tuple
import asyncio
import ipaddress

from .config import settings

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        response: Response = await call_next(request)
        response.headers.setdefault("X-Content-Type-Options", "nosniff")
        response.headers.setdefault("X-Frame-Options", "DENY")
        response.headers.setdefault("Referrer-Policy", "no-referrer")
        # Set HSTS at your TLS proxy (requires HTTPS)
        # response.headers.setdefault("Strict-Transport-Security", "max-age=63072000; includeSubDomains; preload")
        response.headers.setdefault("Permissions-Policy", "geolocation=()")
        return response

_BUCKETS: Dict[str, Tuple[float, float]] = {}
RATE = settings.RATE_LIMIT_RPS
BURST = float(settings.RATE_LIMIT_BURST)

def _client_ip(request: Request) -> str:
    xfwd = request.headers.get("x-forwarded-for")
    ip = (xfwd.split(",")[0].strip() if xfwd else (request.client.host if request.client else "0.0.0.0"))
    try:
        return ipaddress.ip_address(ip).compressed
    except ValueError:
        return "0.0.0.0"

class RateLimitMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        ip = _client_ip(request)
        now = monotonic()
        tokens, last = _BUCKETS.get(ip, (BURST, now))
        tokens = min(BURST, tokens + RATE * (now - last))
        if tokens < 1.0:
            return JSONResponse({"detail": "Too Many Requests"}, status_code=429)
        _BUCKETS[ip] = (tokens - 1.0, now)
        return await call_next(request)

# global semaphore (backpressure for heavy endpoints)
heavy_semaphore = asyncio.Semaphore(settings.MAX_INFLIGHT_JOBS)

async def with_semaphore(coro):
    async with heavy_semaphore:
        return await coro

async def cpu_bound(fn, *args, **kwargs):
    # Run sync (CPU-ish) code in a thread so the event loop stays responsive.
    return await asyncio.to_thread(fn, *args, **kwargs)
`;
}

function tpl_app_routes_index_py() {
  return `"""
app/routes/__init__.py
Central router aggregator mounted at /api in main.py
"""
from fastapi import APIRouter
from .meta_routes import router as meta_router
from .auth_routes import router as auth_router
from .demo_routes import router as demo_router
from .mail_routes import router as mail_router

api_router = APIRouter(prefix="/api")
api_router.include_router(meta_router)
api_router.include_router(auth_router)
api_router.include_router(demo_router)
api_router.include_router(mail_router)
`;
}

function tpl_app_routes_meta_py() {
  return `"""
app/routes/meta_routes.py
Operational endpoints: health/readiness for LB/monitoring.
"""
from datetime import datetime
from fastapi import APIRouter

router = APIRouter(tags=["meta"])

@router.get("/health")
async def health():
    return {"status": "ok", "time": datetime.utcnow().isoformat()}

@router.get("/ready")
async def ready():
    return {"ready": True}
`;
}

function tpl_app_routes_auth_py() {
  return `"""
app/routes/auth_routes.py
Auth endpoints: signup/login/me using in-memory store for demo.
Swap to real DB later; JWT remains the same.
"""
from fastapi import APIRouter, HTTPException, Depends, status
from datetime import datetime
from ..models import SignupIn, LoginIn, TokenOut, ProfileOut, USERS
from ..auth import hash_password, verify_password, create_jwt, get_current_user

router = APIRouter(prefix="/auth", tags=["auth"])

@router.post("/signup", response_model=ProfileOut)
async def signup(body: SignupIn):
    if body.email in USERS:
        raise HTTPException(status_code=409, detail="Email already registered")
    USERS[body.email] = {"password_hash": hash_password(body.password), "created_at": datetime.utcnow()}
    u = USERS[body.email]
    return ProfileOut(email=body.email, created_at=u["created_at"])

@router.post("/login", response_model=TokenOut)
async def login(body: LoginIn):
    u = USERS.get(body.email)
    if not u or not verify_password(body.password, u["password_hash"]):
        raise HTTPException(status_code=401, detail="Invalid credentials")
    token = create_jwt(body.email)
    return TokenOut(access_token=token, expires_minutes=60)

@router.get("/me", response_model=ProfileOut)
async def me(current_email: str = Depends(get_current_user)):
    u = USERS[current_email]
    return ProfileOut(email=current_email, created_at=u["created_at"])
`;
}

function tpl_app_routes_demo_py() {
  return `"""
app/routes/demo_routes.py
Concurrency demos:
- /api/demo/io          -> parallel http calls
- /api/demo/cpu         -> CPU offload with to_thread
- /api/demo/heavy       -> guarded by semaphore
- /api/demo/background  -> post-response background tasks
"""
from typing import Any
import time, asyncio
from fastapi import APIRouter, Request, BackgroundTasks
import httpx
from ..utils import with_semaphore, cpu_bound

router = APIRouter(prefix="/demo", tags=["concurrency"])

@router.get("/io")
async def demo_parallel_io(request: Request, q: str = "fastapi"):
    get_client = request.app.state.http_client
    client: httpx.AsyncClient = get_client()
    assert client is not None, "HTTP client not started yet"
    async def one(i: int):
        r = await client.get("https://httpbin.org/delay/1", params={"n": i, "q": q})
        r.raise_for_status()
        return r.json()
    t0 = time.perf_counter()
    results = await asyncio.gather(one(1), one(2), one(3))
    return {"kind": "parallel-io", "took_sec": round(time.perf_counter()-t0,3), "results": results}

@router.get("/cpu")
async def demo_cpu(n: int = 30_000_00):
    def slow_sum(k: int) -> int:
        s = 0
        for i in range(k): s += i
        return s
    t0 = time.perf_counter()
    s = await cpu_bound(slow_sum, n)
    return {"kind": "cpu-offloaded", "sum": s, "took_sec": round(time.perf_counter()-t0,3)}

@router.get("/heavy")
async def demo_heavy_guarded():
    async def heavy():
        await asyncio.sleep(1.5)
        return {"ok": True}
    t0 = time.perf_counter()
    out = await with_semaphore(heavy())
    return {"guarded": True, "took_sec": round(time.perf_counter()-t0,3), "out": out}

@router.post("/background")
async def demo_background(background: BackgroundTasks, payload: dict[str, Any]):
    def write_log(data: dict):
        with open("/tmp/bg.log", "a") as f:
            f.write(f"{time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())} {data}\\n")
    background.add_task(write_log, payload)
    return {"accepted": True}
`;
}

function tpl_app_routes_mail_py() {
  return `"""
app/routes/mail_routes.py
API-only project but we keep Jinja just to demonstrate email template rendering.
No HTML pages are served; this just returns rendered string.
"""
from fastapi import APIRouter
from jinja2 import Template

router = APIRouter(prefix="/mail", tags=["mail"])

WELCOME_TMPL = Template(\"\"\"\
Hello {{ user }},
Welcome to our API!
This is a plain-text email template rendered with Jinja2.
\"\"\")

@router.get("/preview")
async def preview_email(user: str = "Friend"):
    return {"rendered": WELCOME_TMPL.render(user=user)}
`;
}

function tpl_app_main_py() {
  return `"""
app/main.py
- App factory pattern
- CORS, security headers, rate limit middlewares
- Shared httpx.AsyncClient lifecycle
- /api router mount
"""
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import httpx

from .config import settings
from .utils import SecurityHeadersMiddleware, RateLimitMiddleware
from .routes import api_router

client: httpx.AsyncClient | None = None

def create_app() -> FastAPI:
    app = FastAPI(title=settings.APP_NAME, version="1.0.0")

    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.CORS_ORIGINS,
        allow_credentials=False,
        allow_methods=["*"],
        allow_headers=["Authorization", "Content-Type"],
    )
    app.add_middleware(SecurityHeadersMiddleware)
    app.add_middleware(RateLimitMiddleware)

    app.include_router(api_router)

    @app.on_event("startup")
    async def on_startup():
        nonlocal client
        client = httpx.AsyncClient(timeout=10.0)

    @app.on_event("shutdown")
    async def on_shutdown():
        nonlocal client
        if client: await client.aclose()

    app.state.http_client = lambda: client
    return app

app = create_app()
`;
}

function tpl_ci_yaml() {
  return `name: ci
on: [push, pull_request]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'
      - name: Install deps
        run: |
          python -m venv .venv
          . .venv/bin/activate
          pip install -r requirements.txt
          pip install black ruff mypy pytest
      - name: Lint (ruff)
        run: . .venv/bin/activate && ruff check .
      - name: Format check (black)
        run: . .venv/bin/activate && black --check .
      - name: Type check (mypy)
        run: . .venv/bin/activate && mypy app
      - name: Test
        run: . .venv/bin/activate && pytest -q
      - name: Docker build
        run: docker build -t fastapi-app:ci .
`;
}

// ---------- generator core ----------
async function run() {
  const args = parseArgs(process.argv);

  if (args.help || args._[0] !== "new" || !args._[1]) {
    out(`Usage:\n  fasg new <project-name> [options]\n\nOptions:\n  -d, --docker      Include Dockerfile (and optional docker-compose)\n  --psg             Enable Postgres scaffold (prompt to include in compose)\n  --msql            Enable MySQL scaffold (prompt to include in compose)\n  --redis           Enable Redis scaffold (prompt to include in compose)\n  --ngnx            Provide Nginx proxy (prompt to include in compose)\n  --ci              Add GitHub Actions (lint/test/build)\n  --port <n>        API port (default 8000)\n  --py <ver>        Python version for Docker (default 3.13.2)\n  -h, --help        Show this help\n`);
    process.exit(args.help ? 0 : 1);
  }

  const project = args._[1];
  const root = path.resolve(process.cwd(), project);
  if (fs.existsSync(root) && fs.readdirSync(root).length) {
    die(`Target directory '${project}' already exists and is not empty.`);
  }
  const port = args.port || 8000;
  const pyVer = args.py || "3.13.2";

  // Interactive prompts for compose inclusions
  let includeComposeApi = false;
  let includePostgres = false;
  let includeMySQL = false;
  let includeRedis = false;
  let includeNginx = false;

  if (args.docker) {
    includeComposeApi = await yesNoPrompt("Include API in docker-compose?");
    if (args.psg) includePostgres = await yesNoPrompt("Include Postgres in docker-compose?");
    if (args.msql) includeMySQL    = await yesNoPrompt("Include MySQL in docker-compose?");
    if (args.redis) includeRedis   = await yesNoPrompt("Include Redis in docker-compose?");
    if (args.ngnx) includeNginx    = await yesNoPrompt("Include Nginx reverse proxy in docker-compose?");
  }

  out(`\nScaffolding '${project}'...\n`);

  // Write files
  writeFileSafe(path.join(root, ".gitignore"), tpl_gitignore());
  writeFileSafe(path.join(root, ".env.example"), tpl_env_example(port));
  writeFileSafe(path.join(root, "requirements.txt"), tpl_requirements());
  writeFileSafe(path.join(root, "pyproject.toml"), tpl_pyproject());
  writeFileSafe(path.join(root, "README.md"), tpl_readme(project));
  writeFileSafe(path.join(root, "LICENSE"), tpl_license_mit(project));
  writeFileSafe(path.join(root, "tests/test_health.py"), tpl_tests());
  writeFileSafe(path.join(root, "gunicorn_conf.py"), tpl_gunicorn_conf());

  // app/
  writeFileSafe(path.join(root, "app/config.py"), tpl_app_config_py());
  writeFileSafe(path.join(root, "app/models.py"), tpl_app_models_py());
  writeFileSafe(path.join(root, "app/auth.py"), tpl_app_auth_py());
  writeFileSafe(path.join(root, "app/utils.py"), tpl_app_utils_py());
  writeFileSafe(path.join(root, "app/main.py"), tpl_app_main_py());

  // routes/
  writeFileSafe(path.join(root, "app/routes/__init__.py"), tpl_app_routes_index_py());
  writeFileSafe(path.join(root, "app/routes/meta_routes.py"), tpl_app_routes_meta_py());
  writeFileSafe(path.join(root, "app/routes/auth_routes.py"), tpl_app_routes_auth_py());
  writeFileSafe(path.join(root, "app/routes/demo_routes.py"), tpl_app_routes_demo_py());
  writeFileSafe(path.join(root, "app/routes/mail_routes.py"), tpl_app_routes_mail_py());

  // Docker
  if (args.docker) {
    writeFileSafe(path.join(root, "Dockerfile"), tpl_dockerfile(pyVer));
    const wantCompose = includeComposeApi || includePostgres || includeMySQL || includeRedis || includeNginx;
    if (wantCompose) {
      writeFileSafe(path.join(root, "compose.yaml"),
        tpl_compose({
          includeApi: includeComposeApi,
          includePostgres,
          includeMySQL,
          includeRedis,
          includeNginx,
          port
        })
      );
      if (includeNginx) {
        writeFileSafe(path.join(root, "nginx.conf"), tpl_nginx_conf(port));
      }
    }
  }

  // CI
  if (args.ci) {
    writeFileSafe(path.join(root, ".github/workflows/ci.yml"), tpl_ci_yaml());
  }

  // Data dir for sqlite default
  writeFileSafe(path.join(root, "data/.keep"), "");

  // Final output
  out(`✅ Done! Project scaffolded at ./${project}\n`);
  out(`Next steps:\n  cd ${project}\n  python -m venv .venv && source .venv/bin/activate\n  pip install -r requirements.txt\n  cp .env.example .env && export JWT_SECRET=$(python - <<'PY'\\nimport secrets;print(secrets.token_hex(32))\\nPY)\n  uvicorn app.main:app --host 0.0.0.0 --port ${port} --reload\n`);
  if (args.docker) {
    out(`Docker:\n  docker build -t ${project}:latest .\n  docker run -p ${port}:${port} -e PORT=${port} -e JWT_SECRET=$(openssl rand -hex 32) ${project}:latest\n`);
    out(`Compose:\n  docker compose up --build\n`);
  }
}

run().catch(e => { err(e); process.exit(1); });
